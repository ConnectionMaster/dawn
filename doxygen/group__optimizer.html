<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Dawn: Optimizer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dawn
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Compiler toolchain for developing high-level DSLs for geophysical fluid dynamics models</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__optimizer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Optimizer</div>  </div>
</div><!--header-->
<div class="contents">

<p>Optimizer infrastructure (including static analysis passes)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1Accesses.html">dawn::Accesses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and write accesses of a statement.  <a href="classdawn_1_1Accesses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1Cache.html">dawn::Cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdawn_1_1Cache.html" title="Cache specification of gridtools. ">Cache</a> specification of gridtools.  <a href="classdawn_1_1Cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1DependencyGraph.html">dawn::DependencyGraph&lt; Derived, EdgeData &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class of all dependency graphs.  <a href="classdawn_1_1DependencyGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1DependencyGraphAccesses.html">dawn::DependencyGraphAccesses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency graph of the accesses.  <a href="classdawn_1_1DependencyGraphAccesses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1DependencyGraphStage.html">dawn::DependencyGraphStage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency graph of the stages.  <a href="classdawn_1_1DependencyGraphStage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1DoMethod.html">dawn::DoMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Do-method is a collection of Statements with corresponding <a class="el" href="classdawn_1_1Accesses.html" title="Read and write accesses of a statement. ">Accesses</a> of a specific vertical region.  <a href="classdawn_1_1DoMethod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdawn_1_1Extent.html">dawn::Extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access extent of a single dimension.  <a href="structdawn_1_1Extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1Extents.html">dawn::Extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three dimensional access extents of a field.  <a href="classdawn_1_1Extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdawn_1_1Field.html">dawn::Field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information of a field.  <a href="structdawn_1_1Field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1Interval.html">dawn::Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a vertical interval, given by a lower and upper bound where a bound is represented by a level and an offset (<code>bound = level + offset</code>)  <a href="classdawn_1_1Interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1MultiStage.html">dawn::MultiStage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdawn_1_1MultiStage.html" title="A MultiStage is represented by a collection of stages and a given exectuion policy. ">MultiStage</a> is represented by a collection of stages and a given exectuion policy.  <a href="classdawn_1_1MultiStage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1OptimizerContext.html">dawn::OptimizerContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context of handling all Optimizations.  <a href="classdawn_1_1OptimizerContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassDataLocalityMetric.html">dawn::PassDataLocalityMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> computes a heuristic measuring the data-locality of each stencil.  <a href="classdawn_1_1PassDataLocalityMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassFieldVersioning.html">dawn::PassFieldVersioning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass resolves potential race condition by introducing double buffering i.e versioning of fields.  <a href="classdawn_1_1PassFieldVersioning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassInlining.html">dawn::PassInlining</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to inline stencil functions.  <a href="classdawn_1_1PassInlining.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassMultiStageSplitter.html">dawn::PassMultiStageSplitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> for splitting multistages due vertical data dependencies.  <a href="classdawn_1_1PassMultiStageSplitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassPrintStencilGraph.html">dawn::PassPrintStencilGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> prints the dependency graph of each stencil to a dot file.  <a href="classdawn_1_1PassPrintStencilGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassSetCaches.html">dawn::PassSetCaches</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which fields can be cached during the executation of the multi-stage.  <a href="classdawn_1_1PassSetCaches.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassSetStageGraph.html">dawn::PassSetStageGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> computes and assign the stage graph of each stencil.  <a href="classdawn_1_1PassSetStageGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassSetStageName.html">dawn::PassSetStageName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass assigns a unique name to each stage and makes <code><a class="el" href="classdawn_1_1StencilInstantiation.html#af0317ee661190552f22a78309302d9dd" title="Get the name associated with the StageID ">StencilInstantiation::getNameFromStageID</a></code> usable.  <a href="classdawn_1_1PassSetStageName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassSSA.html">dawn::PassSSA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts each DAG of a stencil into SSA form (Static Single Assignment)  <a href="classdawn_1_1PassSSA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassStageMerger.html">dawn::PassStageMerger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to merge stages into to the same Do-Method (if there are no horizontal dependencies) or into seperate Do-Methods if their vertical intervals do not overlap.  <a href="classdawn_1_1PassStageMerger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassStageReordering.html">dawn::PassStageReordering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> for reordering stages to increase data locility.  <a href="classdawn_1_1PassStageReordering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassStageSplitter.html">dawn::PassStageSplitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> for splitting stages due to horizontal non-pointwiese read-before-write data dependencies.  <a href="classdawn_1_1PassStageSplitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassStencilSplitter.html">dawn::PassStencilSplitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> for splitting stencils due to software limitations i.e stencils are too large.  <a href="classdawn_1_1PassStencilSplitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassTemporaryFirstAccess.html">dawn::PassTemporaryFirstAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass checks the first access to a temporary to avoid unitialized memory accesses.  <a href="classdawn_1_1PassTemporaryFirstAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassTemporaryMerger.html">dawn::PassTemporaryMerger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdawn_1_1Pass.html" title="Abstract base class of all optimization and analyzer passes. ">Pass</a> to merge temporaries.  <a href="classdawn_1_1PassTemporaryMerger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1PassTemporaryType.html">dawn::PassTemporaryType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the correct type of the temporaries.  <a href="classdawn_1_1PassTemporaryType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdawn_1_1ReadBeforeWriteConflict.html">dawn::ReadBeforeWriteConflict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of the vertical dependency analysis algorithm.  <a href="structdawn_1_1ReadBeforeWriteConflict.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1ReorderStrategy.html">dawn::ReorderStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for various reodering strategies.  <a href="classdawn_1_1ReorderStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1ReoderStrategyGreedy.html">dawn::ReoderStrategyGreedy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reordering strategy which tries to move each stage upwards as far as possible under the sole constraint that the extent of any field does not exeed the maximum halo points.  <a href="classdawn_1_1ReoderStrategyGreedy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1ReoderStrategyPartitioning.html">dawn::ReoderStrategyPartitioning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reordering strategy which uses S-cut graph partitioning to reorder the stages and statements.  <a href="classdawn_1_1ReoderStrategyPartitioning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1Stage.html">dawn::Stage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdawn_1_1Stage.html" title="A Stage is represented by a collection of statements grouped into DoMethod of non-overlapping vertica...">Stage</a> is represented by a collection of statements grouped into <a class="el" href="classdawn_1_1DoMethod.html" title="A Do-method is a collection of Statements with corresponding Accesses of a specific vertical region...">DoMethod</a> of non-overlapping vertical intervals.  <a href="classdawn_1_1Stage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StatementAccessesPair.html">dawn::StatementAccessesPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structdawn_1_1Statement.html" title="Wrapper for AST statements of the SIR which contains additional information. ">Statement</a> with corresponding <a class="el" href="classdawn_1_1Accesses.html" title="Read and write accesses of a statement. ">Accesses</a>.  <a href="classdawn_1_1StatementAccessesPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1Stencil.html">dawn::Stencil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdawn_1_1Stencil.html" title="A Stencil is represented by a collection of MultiStages. ">Stencil</a> is represented by a collection of MultiStages.  <a href="classdawn_1_1Stencil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StencilFunctionInstantiation.html">dawn::StencilFunctionInstantiation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific instantiation of a stencil function.  <a href="classdawn_1_1StencilFunctionInstantiation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StencilInstantiation.html">dawn::StencilInstantiation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific instantiation of a stencil.  <a href="classdawn_1_1StencilInstantiation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdawn_1_1Statement.html">dawn::Statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <a class="el" href="classdawn_1_1AST.html" title="Abstract syntax tree of the SIR. ">AST</a> statements of the <a class="el" href="structdawn_1_1SIR.html" title="Definition of the Stencil Intermediate Representation (SIR) ">SIR</a> which contains additional information.  <a href="structdawn_1_1Statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga870b2bcbca496ec52f5dd261a89de8bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga870b2bcbca496ec52f5dd261a89de8bc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#ga870b2bcbca496ec52f5dd261a89de8bc">dawn::LoopOrderKind</a> { <b>LK_Forward</b> = 0, 
<b>LK_Backward</b>, 
<b>LK_Parallel</b>
 }<tr class="memdesc:ga870b2bcbca496ec52f5dd261a89de8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop order of a multi-stage and stages. <br /></td></tr>
</td></tr>
<tr class="separator:ga870b2bcbca496ec52f5dd261a89de8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga503cc9765745546dc88f27c38b846e30"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#ga503cc9765745546dc88f27c38b846e30">dawn::Interval::makeCodeGenName</a> (const Interval &amp;interval)</td></tr>
<tr class="memdesc:ga503cc9765745546dc88f27c38b846e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a name uniquely identifying the interval for code generation.  <a href="#ga503cc9765745546dc88f27c38b846e30">More...</a><br /></td></tr>
<tr class="separator:ga503cc9765745546dc88f27c38b846e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2f5cee03575fba553f9c950bb13b40"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Interval &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#ga9f2f5cee03575fba553f9c950bb13b40">dawn::Interval::computeGapIntervals</a> (const Interval &amp;axis, const std::vector&lt; Interval &gt; &amp;intervals)</td></tr>
<tr class="memdesc:ga9f2f5cee03575fba553f9c950bb13b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a contigeous, non-overlapping set of intervals spanning the entire <code>axis</code> by filling the gaps of <code>intervals</code>  <a href="#ga9f2f5cee03575fba553f9c950bb13b40">More...</a><br /></td></tr>
<tr class="separator:ga9f2f5cee03575fba553f9c950bb13b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae89baa703dfd24dbdd89c671de66db2"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Interval &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#gaae89baa703dfd24dbdd89c671de66db2">dawn::Interval::computeLevelUnion</a> (const std::vector&lt; Interval &gt; &amp;intervals)</td></tr>
<tr class="memdesc:gaae89baa703dfd24dbdd89c671de66db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a set of non-overlapping, adjacent intervals of the given set of intervals where all interval levels are preserved (i.e a union of all levels of the given intervals)  <a href="#gaae89baa703dfd24dbdd89c671de66db2">More...</a><br /></td></tr>
<tr class="separator:gaae89baa703dfd24dbdd89c671de66db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac87c2bf8411ae8a7c4a4e4bf831656f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac87c2bf8411ae8a7c4a4e4bf831656f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#gaac87c2bf8411ae8a7c4a4e4bf831656f">dawn::operator&lt;&lt;</a> (std::ostream &amp;os, LoopOrderKind loopOrder)</td></tr>
<tr class="memdesc:gaac87c2bf8411ae8a7c4a4e4bf831656f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream loop order. <br /></td></tr>
<tr class="separator:gaac87c2bf8411ae8a7c4a4e4bf831656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84026587e233f10ef8c890c70a9d737a"><td class="memItemLeft" align="right" valign="top">ReadBeforeWriteConflict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#ga84026587e233f10ef8c890c70a9d737a">dawn::hasVerticalReadBeforeWriteConflict</a> (const DependencyGraphAccesses *graph, LoopOrderKind loopOrder)</td></tr>
<tr class="memdesc:ga84026587e233f10ef8c890c70a9d737a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the graph contains any vertical non-pointwise read-before-write conflicts in the loop- or counter-loop-order.  <a href="group__optimizer.html#ga84026587e233f10ef8c890c70a9d737a">More...</a><br /></td></tr>
<tr class="separator:ga84026587e233f10ef8c890c70a9d737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894114858810316c885532dc333399dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#ga894114858810316c885532dc333399dd">dawn::hasHorizontalReadBeforeWriteConflict</a> (const DependencyGraphAccesses *graph)</td></tr>
<tr class="memdesc:ga894114858810316c885532dc333399dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the graph contains any horizontal non-pointwise read-before-write conflicts.  <a href="group__optimizer.html#ga894114858810316c885532dc333399dd">More...</a><br /></td></tr>
<tr class="separator:ga894114858810316c885532dc333399dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dfc848a67ce8692378260caddf5cde7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#ga0dfc848a67ce8692378260caddf5cde7">dawn::renameAccessIDInAccesses</a> (StencilInstantiation *instantiation, int oldAccessID, int newAccessID, ArrayRef&lt; std::shared_ptr&lt; StatementAccessesPair &gt;&gt; statementAccessesPairs)</td></tr>
<tr class="memdesc:ga0dfc848a67ce8692378260caddf5cde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename all occurrences of <code>oldAccessID</code> to <code>newAccessID</code> in the in the stencil or stencil-function instantiation.  <a href="group__optimizer.html#ga0dfc848a67ce8692378260caddf5cde7">More...</a><br /></td></tr>
<tr class="separator:ga0dfc848a67ce8692378260caddf5cde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Renaming routines</h2></td></tr>
<tr class="memitem:gaa1a8d0e0a322bc485e774ee202b19bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optimizer.html#gaa1a8d0e0a322bc485e774ee202b19bfc">dawn::renameAccessIDInStmts</a> (StencilInstantiation *instantiation, int oldAccessID, int newAccessID, ArrayRef&lt; std::shared_ptr&lt; StatementAccessesPair &gt;&gt; statementAccessesPairs)</td></tr>
<tr class="memdesc:gaa1a8d0e0a322bc485e774ee202b19bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename all occurrences of <code>oldAccessID</code> to <code>newAccessID</code> in the <code>stmts</code> by updating the AccessID maps.  <a href="group__optimizer.html#gaa1a8d0e0a322bc485e774ee202b19bfc">More...</a><br /></td></tr>
<tr class="separator:gaa1a8d0e0a322bc485e774ee202b19bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de8baf66fc476851331822abb5556f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2de8baf66fc476851331822abb5556f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dawn::renameAccessIDInStmts</b> (StencilFunctionInstantiation *instantiation, int oldAccessID, int newAccessID, ArrayRef&lt; std::shared_ptr&lt; StatementAccessesPair &gt;&gt; statementAccessesPairs)</td></tr>
<tr class="separator:ga2de8baf66fc476851331822abb5556f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0253307b4aea2d1db60f614f84ecedf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0253307b4aea2d1db60f614f84ecedf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dawn::renameAccessIDInExpr</b> (StencilInstantiation *instantiation, int oldAccessID, int newAccessID, std::shared_ptr&lt; Expr &gt; &amp;expr)</td></tr>
<tr class="separator:ga0253307b4aea2d1db60f614f84ecedf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Optimizer infrastructure (including static analysis passes) </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9f2f5cee03575fba553f9c950bb13b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Interval &gt; dawn::Interval::computeGapIntervals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdawn_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdawn_1_1Interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a contigeous, non-overlapping set of intervals spanning the entire <code>axis</code> by filling the gaps of <code>intervals</code> </p>
<p>The <code>intervals</code> do not need to be sorted but they can't be overlapping. The computed intervals are sorted in ascending order (i.e the first intervals is the lowest).</p>
<p><b>Example:</b> Given the axis A = [0, 10] (given by a lower and upper bound) and 2 intervals (I1, I2) with:</p><ul>
<li>I1 = [0, 1]</li>
<li>I2 = [3, 5]</li>
</ul>
<p>The computed gap intverals would be G1 and G2 with:</p><ul>
<li>G1 = [2, 2]</li>
<li>G2 = [6, 10]</li>
</ul>
<p>and this function will return (R1, R2, R3, R4):</p><ul>
<li>R1 = [0, 1]</li>
<li>R2 = [2, 2]</li>
<li>R3 = [3, 5]</li>
<li>R4 = [6, 10]</li>
</ul>
<p>Hence, we filled the "gaps". </p>

<p>Definition at line <a class="el" href="Interval_8cpp_source.html#l00097">97</a> of file <a class="el" href="Interval_8cpp_source.html">Interval.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaae89baa703dfd24dbdd89c671de66db2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Interval &gt; dawn::Interval::computeLevelUnion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdawn_1_1Interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>intervals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a set of non-overlapping, adjacent intervals of the given set of intervals where all interval levels are preserved (i.e a union of all levels of the given intervals) </p>
<p>Each level is represented as a single interval.</p>
<p><b>Example:</b> Given 4 intervals (I1, I2, I3, I4) with:</p><ul>
<li>I1 = [0, 20]</li>
<li>I2 = [5, 21]</li>
<li>I3 = [5, 10]</li>
<li>I4 = [21, 21]</li>
</ul>
<p>The computed union would span the axis [0, 21] with levels at {5, 10, 20} i.e in this case the function would return 8 intervals:</p><ul>
<li>CI1 = [0, 0]</li>
<li>CI2 = [1, 4]</li>
<li>CI3 = [5, 5]</li>
<li>CI4 = [6, 9]</li>
<li>CI5 = [10, 10]</li>
<li>CI6 = [11, 19]</li>
<li>CI7 = [20, 20]</li>
<li>CI8 = [21, 21] </li>
</ul>

<p>Definition at line <a class="el" href="Interval_8cpp_source.html#l00073">73</a> of file <a class="el" href="Interval_8cpp_source.html">Interval.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga894114858810316c885532dc333399dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dawn::hasHorizontalReadBeforeWriteConflict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdawn_1_1DependencyGraphAccesses.html">DependencyGraphAccesses</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the graph contains any horizontal non-pointwise read-before-write conflicts. </p>
<p>The algorithm will check if there are two nodes which are connected by a non-pointwise edge with the first node being an output field (i.e no other nodes depend on it) and the second node being <b>not</b> an input field (i.e other node depends on it). This simply means we detect non-pointwise read-before-writes. Consider the following example:</p>
<div class="fragment"><div class="line">lap = u;</div><div class="line">out = lap(i+1);</div></div><!-- fragment --><p>We will potentially read <code>lap</code> at <code>i+1</code> before it has been written! This is due to the fact that our parallel model assumes each statement is embarrassingly parallel in the horizontal. The solution is is thus to insert a synchronization point between the two statements.</p>
<div class="fragment"><div class="line">lap = u;</div><div class="line">__syncthreads():</div><div class="line">out = lap(i+1);</div></div><!-- fragment --><p>This can be formally achieved by splitting the two statements into a different stages.</p>
<dl class="section note"><dt>Note</dt><dd>If there are no conflicts the graph defines a valid <a class="el" href="classdawn_1_1Stage.html" title="A Stage is represented by a collection of statements grouped into DoMethod of non-overlapping vertica...">Stage</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdawn_1_1Stage.html" title="A Stage is represented by a collection of statements grouped into DoMethod of non-overlapping vertica...">Stage</a> </dd></dl>

<p>Definition at line <a class="el" href="ReadBeforeWriteConflict_8cpp_source.html#l00146">146</a> of file <a class="el" href="ReadBeforeWriteConflict_8cpp_source.html">ReadBeforeWriteConflict.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga84026587e233f10ef8c890c70a9d737a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReadBeforeWriteConflict dawn::hasVerticalReadBeforeWriteConflict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdawn_1_1DependencyGraphAccesses.html">DependencyGraphAccesses</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__optimizer.html#ga870b2bcbca496ec52f5dd261a89de8bc">LoopOrderKind</a>&#160;</td>
          <td class="paramname"><em>loopOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the graph contains any vertical non-pointwise read-before-write conflicts in the loop- or counter-loop-order. </p>
<p>The algorithm will check if there are two nodes which are connected by a non-pointwise edge with the first node being an output field (i.e no other nodes depend on it) and the second node being <b>not</b> an input field (i.e an other node depends on it). This simply means we detect non-pointwise read-before-writes. Consider the following example:</p>
<div class="fragment"><div class="line">vertical_region(k_start, k_end - 1}) {</div><div class="line">  lap = u;</div><div class="line">  out = lap(k+1);</div><div class="line">}</div></div><!-- fragment --><p>As we have a forward loop, we read <code>lap</code> at <code>k+1</code> before it has been written! To bypass this problem, we have to split the two statements into two different k-loops (i.e multi-stages).</p>
<div class="fragment"><div class="line">vertical_region(k_start, k_end - 1)</div><div class="line">  lap = u;</div><div class="line"></div><div class="line">vertical_region(k_start, k_end - 1)</div><div class="line">  out = lap(k+1);</div></div><!-- fragment --><p>Note that in this scenario the first k-loop could be executed in parallel as there are no vertical dependencies.</p>
<dl class="section note"><dt>Note</dt><dd>If there are no conflicts the graph defines a valid <a class="el" href="classdawn_1_1MultiStage.html" title="A MultiStage is represented by a collection of stages and a given exectuion policy. ">MultiStage</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdawn_1_1MultiStage.html" title="A MultiStage is represented by a collection of stages and a given exectuion policy. ">MultiStage</a> </dd></dl>

<p>Definition at line <a class="el" href="ReadBeforeWriteConflict_8cpp_source.html#l00141">141</a> of file <a class="el" href="ReadBeforeWriteConflict_8cpp_source.html">ReadBeforeWriteConflict.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga503cc9765745546dc88f27c38b846e30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string dawn::Interval::makeCodeGenName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdawn_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a name uniquely identifying the interval for code generation. </p>

<p>Definition at line <a class="el" href="Interval_8cpp_source.html#l00050">50</a> of file <a class="el" href="Interval_8cpp_source.html">Interval.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0dfc848a67ce8692378260caddf5cde7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dawn::renameAccessIDInAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StencilInstantiation.html">StencilInstantiation</a> *&#160;</td>
          <td class="paramname"><em>instantiation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oldAccessID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newAccessID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdawn_1_1ArrayRef.html">ArrayRef</a>&lt; std::shared_ptr&lt; <a class="el" href="classdawn_1_1StatementAccessesPair.html">StatementAccessesPair</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>statementAccessesPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename all occurrences of <code>oldAccessID</code> to <code>newAccessID</code> in the in the stencil or stencil-function instantiation. </p>
<p>For stencil-function instantiation the caller and callee accesses are renamed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldAccessID</td><td>Old AccessID of the field </td></tr>
    <tr><td class="paramname">newAccessID</td><td>New AccessID of the field </td></tr>
    <tr><td class="paramname">statementAccessesPairs</td><td><a class="el" href="classdawn_1_1Accesses.html" title="Read and write accesses of a statement. ">Accesses</a> to update </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Renaming_8cpp_source.html#l00117">117</a> of file <a class="el" href="Renaming_8cpp_source.html">Renaming.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1a8d0e0a322bc485e774ee202b19bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dawn::renameAccessIDInStmts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StencilInstantiation.html">StencilInstantiation</a> *&#160;</td>
          <td class="paramname"><em>instantiation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oldAccessID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newAccessID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdawn_1_1ArrayRef.html">ArrayRef</a>&lt; std::shared_ptr&lt; <a class="el" href="classdawn_1_1StatementAccessesPair.html">StatementAccessesPair</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>statementAccessesPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename all occurrences of <code>oldAccessID</code> to <code>newAccessID</code> in the <code>stmts</code> by updating the AccessID maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instantiation</td><td>Instantiation in which AccessID maps are updated </td></tr>
    <tr><td class="paramname">oldAccessID</td><td>Old AccessID of the field </td></tr>
    <tr><td class="paramname">newAccessID</td><td>New AccessID of the field </td></tr>
    <tr><td class="paramname">statementAccessesPair</td><td><a class="el" href="classdawn_1_1AST.html" title="Abstract syntax tree of the SIR. ">AST</a> statements to inspect </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Renaming_8cpp_source.html#l00087">87</a> of file <a class="el" href="Renaming_8cpp_source.html">Renaming.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
