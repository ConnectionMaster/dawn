<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Dawn: dawn::StringRef Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dawn
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Compiler toolchain for developing high-level DSLs for geophysical fluid dynamics models</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdawn_1_1StringRef.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdawn_1_1StringRef-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dawn::StringRef Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represent a constant reference to a string, i.e. a character array and a length, which need not be null terminated.  
 <a href="classdawn_1_1StringRef.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StringRef_8h_source.html">StringRef.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a408ec273f877054e78f2efd9a16cdd34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a408ec273f877054e78f2efd9a16cdd34"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a408ec273f877054e78f2efd9a16cdd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3abed45c79f82fe107935c453950088"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3abed45c79f82fe107935c453950088"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ae3abed45c79f82fe107935c453950088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8102c0832a94302972780f83bf9cca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a8102c0832a94302972780f83bf9cca"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a4a8102c0832a94302972780f83bf9cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a815b951f4572a407c004e47eae909bd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a815b951f4572a407c004e47eae909bd6"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr class="separator:a815b951f4572a407c004e47eae909bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d37257adee8ac4ddb793215f080b56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0d37257adee8ac4ddb793215f080b56"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:aa0d37257adee8ac4ddb793215f080b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305116932bc6b5b573abdbadf49c765a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a305116932bc6b5b573abdbadf49c765a"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_begin</b> () const </td></tr>
<tr class="separator:a305116932bc6b5b573abdbadf49c765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c949b94e0fdf18584800696b64b7df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4c949b94e0fdf18584800696b64b7df"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_end</b> () const </td></tr>
<tr class="separator:ae4c949b94e0fdf18584800696b64b7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Operations</div></td></tr>
<tr class="memitem:a107055aa239a9f486c35b0f682c4a6fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a107055aa239a9f486c35b0f682c4a6fd"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a107055aa239a9f486c35b0f682c4a6fd">data</a> () const </td></tr>
<tr class="memdesc:a107055aa239a9f486c35b0f682c4a6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the start of the string (which may not be null terminated) <br /></td></tr>
<tr class="separator:a107055aa239a9f486c35b0f682c4a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80b31fb06b7c4b38ba56eb2194beceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac80b31fb06b7c4b38ba56eb2194beceb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ac80b31fb06b7c4b38ba56eb2194beceb">empty</a> () const </td></tr>
<tr class="memdesc:ac80b31fb06b7c4b38ba56eb2194beceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string is empty. <br /></td></tr>
<tr class="separator:ac80b31fb06b7c4b38ba56eb2194beceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2803a41e8fbee9defb19f20747beaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d2803a41e8fbee9defb19f20747beaf"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a8d2803a41e8fbee9defb19f20747beaf">size</a> () const </td></tr>
<tr class="memdesc:a8d2803a41e8fbee9defb19f20747beaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string size. <br /></td></tr>
<tr class="separator:a8d2803a41e8fbee9defb19f20747beaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e62e04c2e12483dc0f36c280402f32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63e62e04c2e12483dc0f36c280402f32"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a63e62e04c2e12483dc0f36c280402f32">front</a> () const </td></tr>
<tr class="memdesc:a63e62e04c2e12483dc0f36c280402f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first character in the string. <br /></td></tr>
<tr class="separator:a63e62e04c2e12483dc0f36c280402f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c84ad4987087bcddb252d595f0139"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa73c84ad4987087bcddb252d595f0139"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#aa73c84ad4987087bcddb252d595f0139">back</a> () const </td></tr>
<tr class="memdesc:aa73c84ad4987087bcddb252d595f0139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last character in the string. <br /></td></tr>
<tr class="separator:aa73c84ad4987087bcddb252d595f0139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad273d58c4bc8bf8c20ab430868283237"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad273d58c4bc8bf8c20ab430868283237"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ad273d58c4bc8bf8c20ab430868283237">equals</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:ad273d58c4bc8bf8c20ab430868283237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for string equality, this is more efficient than <a class="el" href="classdawn_1_1StringRef.html#ae5c3f5b63c34422a701b4190265dfda9" title="Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less than...">compare()</a> when the relative ordering of inequal strings isn't needed. <br /></td></tr>
<tr class="separator:ad273d58c4bc8bf8c20ab430868283237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13847679002c782ad343471c093a1265"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13847679002c782ad343471c093a1265"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a13847679002c782ad343471c093a1265">equals_lower</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:a13847679002c782ad343471c093a1265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for string equality, ignoring case. <br /></td></tr>
<tr class="separator:a13847679002c782ad343471c093a1265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c3f5b63c34422a701b4190265dfda9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c3f5b63c34422a701b4190265dfda9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ae5c3f5b63c34422a701b4190265dfda9">compare</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:ae5c3f5b63c34422a701b4190265dfda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less than, equal to, or greater than the <code>RHS</code>. <br /></td></tr>
<tr class="separator:ae5c3f5b63c34422a701b4190265dfda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac9aa855a899ccf546c6630e31d41f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ac9aa855a899ccf546c6630e31d41f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a5ac9aa855a899ccf546c6630e31d41f0">compare_lower</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:a5ac9aa855a899ccf546c6630e31d41f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, ignoring case. <br /></td></tr>
<tr class="separator:a5ac9aa855a899ccf546c6630e31d41f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac450be8cc5c4a2402dd0b3bc7b943e9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac450be8cc5c4a2402dd0b3bc7b943e9a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ac450be8cc5c4a2402dd0b3bc7b943e9a">compare_numeric</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:ac450be8cc5c4a2402dd0b3bc7b943e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, treating sequences of digits as numbers. <br /></td></tr>
<tr class="separator:ac450be8cc5c4a2402dd0b3bc7b943e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad504a74304c2847769a7e9cfcf8e0ffe"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ad504a74304c2847769a7e9cfcf8e0ffe">edit_distance</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Other, bool AllowReplacements=true, unsigned MaxEditDistance=0) const </td></tr>
<tr class="memdesc:ad504a74304c2847769a7e9cfcf8e0ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the edit distance between this string and another string.  <a href="#ad504a74304c2847769a7e9cfcf8e0ffe">More...</a><br /></td></tr>
<tr class="separator:ad504a74304c2847769a7e9cfcf8e0ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743adb29ece0bc232ba2289cf355141"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2743adb29ece0bc232ba2289cf355141"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a2743adb29ece0bc232ba2289cf355141">str</a> () const </td></tr>
<tr class="memdesc:a2743adb29ece0bc232ba2289cf355141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents as an std::string. <br /></td></tr>
<tr class="separator:a2743adb29ece0bc232ba2289cf355141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d45628903453df0d2865474ffbbe787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d45628903453df0d2865474ffbbe787"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a5d45628903453df0d2865474ffbbe787">lower</a> () const </td></tr>
<tr class="memdesc:a5d45628903453df0d2865474ffbbe787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given ASCII string to lowercase. <br /></td></tr>
<tr class="separator:a5d45628903453df0d2865474ffbbe787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fd1c4445dbe5faee55c2b2bd31bc38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33fd1c4445dbe5faee55c2b2bd31bc38"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a33fd1c4445dbe5faee55c2b2bd31bc38">upper</a> () const </td></tr>
<tr class="memdesc:a33fd1c4445dbe5faee55c2b2bd31bc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given ASCII string to uppercase. <br /></td></tr>
<tr class="separator:a33fd1c4445dbe5faee55c2b2bd31bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operator Overloads</div></td></tr>
<tr class="memitem:a93ccf4b36895e4d5e4ba1c012008453e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ccf4b36895e4d5e4ba1c012008453e"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t Index) const </td></tr>
<tr class="separator:a93ccf4b36895e4d5e4ba1c012008453e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7a0d03452514ae39cdbfc3ba657eee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc7a0d03452514ae39cdbfc3ba657eee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T, std::string &gt;::value, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#abc7a0d03452514ae39cdbfc3ba657eee">operator=</a> (T &amp;&amp;Str)=delete</td></tr>
<tr class="memdesc:abc7a0d03452514ae39cdbfc3ba657eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow accidental assignment from a temporary std::string.  <a href="#abc7a0d03452514ae39cdbfc3ba657eee">More...</a><br /></td></tr>
<tr class="separator:abc7a0d03452514ae39cdbfc3ba657eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Predicates</div></td></tr>
<tr class="memitem:ac85d8d2ece7cd9129f270a6902bab53b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85d8d2ece7cd9129f270a6902bab53b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ac85d8d2ece7cd9129f270a6902bab53b">startswith</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Prefix) const </td></tr>
<tr class="memdesc:ac85d8d2ece7cd9129f270a6902bab53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>. <br /></td></tr>
<tr class="separator:ac85d8d2ece7cd9129f270a6902bab53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182002e7de50447e3714b6021a8c39b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a182002e7de50447e3714b6021a8c39b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a182002e7de50447e3714b6021a8c39b3">startswith_lower</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Prefix) const </td></tr>
<tr class="memdesc:a182002e7de50447e3714b6021a8c39b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>, ignoring case. <br /></td></tr>
<tr class="separator:a182002e7de50447e3714b6021a8c39b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fb71a4a49822b0b87ff564298c4fea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85fb71a4a49822b0b87ff564298c4fea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a85fb71a4a49822b0b87ff564298c4fea">endswith</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Suffix) const </td></tr>
<tr class="memdesc:a85fb71a4a49822b0b87ff564298c4fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>. <br /></td></tr>
<tr class="separator:a85fb71a4a49822b0b87ff564298c4fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f51863cdc984a2bdad4be5b65961034"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f51863cdc984a2bdad4be5b65961034"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a7f51863cdc984a2bdad4be5b65961034">endswith_lower</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Suffix) const </td></tr>
<tr class="memdesc:a7f51863cdc984a2bdad4be5b65961034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>, ignoring case. <br /></td></tr>
<tr class="separator:a7f51863cdc984a2bdad4be5b65961034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Searching</div></td></tr>
<tr class="memitem:af1bad06986daa9948f66b5c6fc90c6fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#af1bad06986daa9948f66b5c6fc90c6fb">find</a> (char C, size_t From=0) const </td></tr>
<tr class="memdesc:af1bad06986daa9948f66b5c6fc90c6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character <code>C</code> in the string.  <a href="#af1bad06986daa9948f66b5c6fc90c6fb">More...</a><br /></td></tr>
<tr class="separator:af1bad06986daa9948f66b5c6fc90c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5de6a6ff661683672a21697c84127f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#aa5de6a6ff661683672a21697c84127f0">find_lower</a> (char C, size_t From=0) const </td></tr>
<tr class="memdesc:aa5de6a6ff661683672a21697c84127f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character <code>C</code> in the string, ignoring case.  <a href="#aa5de6a6ff661683672a21697c84127f0">More...</a><br /></td></tr>
<tr class="separator:aa5de6a6ff661683672a21697c84127f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275bc8a0c3771329b141f16890224869"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a275bc8a0c3771329b141f16890224869">find_if</a> (<a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F, size_t From=0) const </td></tr>
<tr class="memdesc:a275bc8a0c3771329b141f16890224869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character satisfying the predicate <code>F</code>.  <a href="#a275bc8a0c3771329b141f16890224869">More...</a><br /></td></tr>
<tr class="separator:a275bc8a0c3771329b141f16890224869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa134e987ac930238c483740b34bff1f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#afa134e987ac930238c483740b34bff1f">find_if_not</a> (<a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F, size_t From=0) const </td></tr>
<tr class="memdesc:afa134e987ac930238c483740b34bff1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character not satisfying the predicate <code>F</code>.  <a href="#afa134e987ac930238c483740b34bff1f">More...</a><br /></td></tr>
<tr class="separator:afa134e987ac930238c483740b34bff1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fef30c745c806174041c5e10483a325"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a2fef30c745c806174041c5e10483a325">find</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Str, size_t From=0) const </td></tr>
<tr class="memdesc:a2fef30c745c806174041c5e10483a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>Str</code> in the string.  <a href="#a2fef30c745c806174041c5e10483a325">More...</a><br /></td></tr>
<tr class="separator:a2fef30c745c806174041c5e10483a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b214811d4ec37a993738e7621dec0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a3b1b214811d4ec37a993738e7621dec0">find_lower</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Str, size_t From=0) const </td></tr>
<tr class="memdesc:a3b1b214811d4ec37a993738e7621dec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>Str</code> in the string, ignoring case.  <a href="#a3b1b214811d4ec37a993738e7621dec0">More...</a><br /></td></tr>
<tr class="separator:a3b1b214811d4ec37a993738e7621dec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a6ab10bdc615aab91258ff5b923b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a2212a6ab10bdc615aab91258ff5b923b">rfind</a> (char C, size_t From=npos) const </td></tr>
<tr class="memdesc:a2212a6ab10bdc615aab91258ff5b923b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last character <code>C</code> in the string.  <a href="#a2212a6ab10bdc615aab91258ff5b923b">More...</a><br /></td></tr>
<tr class="separator:a2212a6ab10bdc615aab91258ff5b923b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174b269c88b2f3284a62af898cab8ef5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a174b269c88b2f3284a62af898cab8ef5">rfind_lower</a> (char C, size_t From=npos) const </td></tr>
<tr class="memdesc:a174b269c88b2f3284a62af898cab8ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last character <code>C</code> in the string, ignoring case.  <a href="#a174b269c88b2f3284a62af898cab8ef5">More...</a><br /></td></tr>
<tr class="separator:a174b269c88b2f3284a62af898cab8ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602e32d304211281e653405057a85912"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a602e32d304211281e653405057a85912">rfind</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Str) const </td></tr>
<tr class="memdesc:a602e32d304211281e653405057a85912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>Str</code> in the string.  <a href="#a602e32d304211281e653405057a85912">More...</a><br /></td></tr>
<tr class="separator:a602e32d304211281e653405057a85912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f92eb7c4acecaeb7d8e09787659091"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a74f92eb7c4acecaeb7d8e09787659091">rfind_lower</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Str) const </td></tr>
<tr class="memdesc:a74f92eb7c4acecaeb7d8e09787659091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>Str</code> in the string, ignoring case.  <a href="#a74f92eb7c4acecaeb7d8e09787659091">More...</a><br /></td></tr>
<tr class="separator:a74f92eb7c4acecaeb7d8e09787659091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0badb6d5916c7dde607d8e9fb03f4b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0badb6d5916c7dde607d8e9fb03f4b8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ac0badb6d5916c7dde607d8e9fb03f4b8">find_first_of</a> (char C, size_t From=0) const </td></tr>
<tr class="memdesc:ac0badb6d5916c7dde607d8e9fb03f4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is <code>C</code>, or npos if not found. Same as find. <br /></td></tr>
<tr class="separator:ac0badb6d5916c7dde607d8e9fb03f4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d1a13ecf028373849ca2430fb75f62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ab2d1a13ecf028373849ca2430fb75f62">find_first_of</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Chars, size_t From=0) const </td></tr>
<tr class="memdesc:ab2d1a13ecf028373849ca2430fb75f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is in <code>Chars</code>, or npos if not found.  <a href="#ab2d1a13ecf028373849ca2430fb75f62">More...</a><br /></td></tr>
<tr class="separator:ab2d1a13ecf028373849ca2430fb75f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a4405d85631a520e8094d397b2e994"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a41a4405d85631a520e8094d397b2e994">find_first_not_of</a> (char C, size_t From=0) const </td></tr>
<tr class="memdesc:a41a4405d85631a520e8094d397b2e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is not <code>C</code> or npos if not found.  <a href="#a41a4405d85631a520e8094d397b2e994">More...</a><br /></td></tr>
<tr class="separator:a41a4405d85631a520e8094d397b2e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae636093995f4674ce79988342688a3fc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ae636093995f4674ce79988342688a3fc">find_first_not_of</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Chars, size_t From=0) const </td></tr>
<tr class="memdesc:ae636093995f4674ce79988342688a3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is not in the string <code>Chars</code>, or npos if not found.  <a href="#ae636093995f4674ce79988342688a3fc">More...</a><br /></td></tr>
<tr class="separator:ae636093995f4674ce79988342688a3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982a7c3b976261c82f38c0438f1e3b4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a982a7c3b976261c82f38c0438f1e3b4b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a982a7c3b976261c82f38c0438f1e3b4b">find_last_of</a> (char C, size_t From=npos) const </td></tr>
<tr class="memdesc:a982a7c3b976261c82f38c0438f1e3b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is <code>C</code>, or npos if not found. <br /></td></tr>
<tr class="separator:a982a7c3b976261c82f38c0438f1e3b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b746c28753a11bb900cf2a7d3a37e49"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a5b746c28753a11bb900cf2a7d3a37e49">find_last_of</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Chars, size_t From=npos) const </td></tr>
<tr class="memdesc:a5b746c28753a11bb900cf2a7d3a37e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is in <code>C</code>, or npos if not found.  <a href="#a5b746c28753a11bb900cf2a7d3a37e49">More...</a><br /></td></tr>
<tr class="separator:a5b746c28753a11bb900cf2a7d3a37e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae3a11e091a3f30f0229d6b289138df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae3a11e091a3f30f0229d6b289138df"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#aaae3a11e091a3f30f0229d6b289138df">find_last_not_of</a> (char C, size_t From=npos) const </td></tr>
<tr class="memdesc:aaae3a11e091a3f30f0229d6b289138df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is not <code>C</code>, or npos if not found. <br /></td></tr>
<tr class="separator:aaae3a11e091a3f30f0229d6b289138df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e3cb4221549c83b2402d8b5d52b2a3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a02e3cb4221549c83b2402d8b5d52b2a3">find_last_not_of</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Chars, size_t From=npos) const </td></tr>
<tr class="memdesc:a02e3cb4221549c83b2402d8b5d52b2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is not in <code>Chars</code>, or npos if not found.  <a href="#a02e3cb4221549c83b2402d8b5d52b2a3">More...</a><br /></td></tr>
<tr class="separator:a02e3cb4221549c83b2402d8b5d52b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae966e20c19f15fcbe65146ebe6776b79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae966e20c19f15fcbe65146ebe6776b79"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ae966e20c19f15fcbe65146ebe6776b79">contains</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Other) const </td></tr>
<tr class="memdesc:ae966e20c19f15fcbe65146ebe6776b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given string is a substring of *this, and false otherwise. <br /></td></tr>
<tr class="separator:ae966e20c19f15fcbe65146ebe6776b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97978c6aa338d8499b283679d0c1ecef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97978c6aa338d8499b283679d0c1ecef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a97978c6aa338d8499b283679d0c1ecef">contains</a> (char C) const </td></tr>
<tr class="memdesc:a97978c6aa338d8499b283679d0c1ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given character is contained in *this, and false otherwise. <br /></td></tr>
<tr class="separator:a97978c6aa338d8499b283679d0c1ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc97ec50a00dd653e9a0d6582784781f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc97ec50a00dd653e9a0d6582784781f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#afc97ec50a00dd653e9a0d6582784781f">contains_lower</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Other) const </td></tr>
<tr class="memdesc:afc97ec50a00dd653e9a0d6582784781f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given string is a substring of *this, and false otherwise. <br /></td></tr>
<tr class="separator:afc97ec50a00dd653e9a0d6582784781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882af0fc19cea0bcf510b96c28f228fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a882af0fc19cea0bcf510b96c28f228fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a882af0fc19cea0bcf510b96c28f228fd">contains_lower</a> (char C) const </td></tr>
<tr class="memdesc:a882af0fc19cea0bcf510b96c28f228fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given character is contained in *this, and false otherwise. <br /></td></tr>
<tr class="separator:a882af0fc19cea0bcf510b96c28f228fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Helpful Algorithms</div></td></tr>
<tr class="memitem:a38e682f4c04ddd12683313368859fbd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38e682f4c04ddd12683313368859fbd5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a38e682f4c04ddd12683313368859fbd5">count</a> (char C) const </td></tr>
<tr class="memdesc:a38e682f4c04ddd12683313368859fbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of occurrences of <code>C</code> in the string. <br /></td></tr>
<tr class="separator:a38e682f4c04ddd12683313368859fbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852134509d89c6f618e6817781c5af3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a852134509d89c6f618e6817781c5af3f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a852134509d89c6f618e6817781c5af3f">count</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Str) const </td></tr>
<tr class="memdesc:a852134509d89c6f618e6817781c5af3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of non-overlapped occurrences of <code>Str</code> in the string. <br /></td></tr>
<tr class="separator:a852134509d89c6f618e6817781c5af3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be8de0cd0874afac40d24fc5bd856fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4be8de0cd0874afac40d24fc5bd856fc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a4be8de0cd0874afac40d24fc5bd856fc">getAsInteger</a> (unsigned Radix, T &amp;Result) const </td></tr>
<tr class="memdesc:a4be8de0cd0874afac40d24fc5bd856fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current string as an integer of the specified radix.  <a href="#a4be8de0cd0874afac40d24fc5bd856fc">More...</a><br /></td></tr>
<tr class="separator:a4be8de0cd0874afac40d24fc5bd856fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe496637fefcae2bdcdeac8ae4d5b1ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe496637fefcae2bdcdeac8ae4d5b1ec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe496637fefcae2bdcdeac8ae4d5b1ec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAsInteger</b> (unsigned Radix, T &amp;Result) const </td></tr>
<tr class="separator:afe496637fefcae2bdcdeac8ae4d5b1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8090209bfc13efd61b7b42f99909d057"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8090209bfc13efd61b7b42f99909d057"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a8090209bfc13efd61b7b42f99909d057">consumeInteger</a> (unsigned Radix, T &amp;Result)</td></tr>
<tr class="memdesc:a8090209bfc13efd61b7b42f99909d057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current string as an integer of the specified radix.  <a href="#a8090209bfc13efd61b7b42f99909d057">More...</a><br /></td></tr>
<tr class="separator:a8090209bfc13efd61b7b42f99909d057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a523aa40fff857fb57984d39cb2c61d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a523aa40fff857fb57984d39cb2c61d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a523aa40fff857fb57984d39cb2c61d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>consumeInteger</b> (unsigned Radix, T &amp;Result)</td></tr>
<tr class="separator:a3a523aa40fff857fb57984d39cb2c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Substring Operations</div></td></tr>
<tr class="memitem:a1cea466138a523489a684676bb233d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a1cea466138a523489a684676bb233d60">substr</a> (size_t Start, size_t N=npos) const </td></tr>
<tr class="memdesc:a1cea466138a523489a684676bb233d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the substring from [Start, Start + N).  <a href="#a1cea466138a523489a684676bb233d60">More...</a><br /></td></tr>
<tr class="separator:a1cea466138a523489a684676bb233d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c759819c1f3496c5ece3c564ad14740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c759819c1f3496c5ece3c564ad14740"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a4c759819c1f3496c5ece3c564ad14740">take_front</a> (size_t N=1) const </td></tr>
<tr class="memdesc:a4c759819c1f3496c5ece3c564ad14740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> equal to 'this' but with only the first <code>N</code> elements remaining. If <code>N</code> is greater than the length of the string, the entire string is returned. <br /></td></tr>
<tr class="separator:a4c759819c1f3496c5ece3c564ad14740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c59fbb1c520e0e0c53548525a3e8359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a9c59fbb1c520e0e0c53548525a3e8359">take_back</a> (size_t N=1) const </td></tr>
<tr class="memdesc:a9c59fbb1c520e0e0c53548525a3e8359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> equal to 'this' but with only the first <code>N</code> elements remaining.  <a href="#a9c59fbb1c520e0e0c53548525a3e8359">More...</a><br /></td></tr>
<tr class="separator:a9c59fbb1c520e0e0c53548525a3e8359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b979d17060a5becdd2100068e86f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3b979d17060a5becdd2100068e86f71"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ab3b979d17060a5becdd2100068e86f71">take_while</a> (<a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const </td></tr>
<tr class="memdesc:ab3b979d17060a5becdd2100068e86f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest prefix of 'this' such that every character in the prefix satisfies the given predicate. <br /></td></tr>
<tr class="separator:ab3b979d17060a5becdd2100068e86f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18195c81484c615437cea3bf52960d92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18195c81484c615437cea3bf52960d92"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a18195c81484c615437cea3bf52960d92">take_until</a> (<a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const </td></tr>
<tr class="memdesc:a18195c81484c615437cea3bf52960d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest prefix of 'this' such that no character in the prefix satisfies the given predicate. <br /></td></tr>
<tr class="separator:a18195c81484c615437cea3bf52960d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda3141c3e83a4e671796aebfeb0287a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abda3141c3e83a4e671796aebfeb0287a"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#abda3141c3e83a4e671796aebfeb0287a">drop_front</a> (size_t N=1) const </td></tr>
<tr class="memdesc:abda3141c3e83a4e671796aebfeb0287a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> equal to 'this' but with the first <code>N</code> elements dropped. <br /></td></tr>
<tr class="separator:abda3141c3e83a4e671796aebfeb0287a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7214c1578ff28ddeba0a7c3759895f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7214c1578ff28ddeba0a7c3759895f"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#aec7214c1578ff28ddeba0a7c3759895f">drop_back</a> (size_t N=1) const </td></tr>
<tr class="memdesc:aec7214c1578ff28ddeba0a7c3759895f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> equal to 'this' but with the last <code>N</code> elements dropped. <br /></td></tr>
<tr class="separator:aec7214c1578ff28ddeba0a7c3759895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc52d171c00f538a09ad46cb665f27b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc52d171c00f538a09ad46cb665f27b6"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#acc52d171c00f538a09ad46cb665f27b6">drop_while</a> (<a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const </td></tr>
<tr class="memdesc:acc52d171c00f538a09ad46cb665f27b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> equal to 'this', but with all characters satisfying the given predicate dropped from the beginning of the string. <br /></td></tr>
<tr class="separator:acc52d171c00f538a09ad46cb665f27b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b743a75e40f0134d349b40021efbe55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b743a75e40f0134d349b40021efbe55"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a4b743a75e40f0134d349b40021efbe55">drop_until</a> (<a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const </td></tr>
<tr class="memdesc:a4b743a75e40f0134d349b40021efbe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> equal to 'this', but with all characters not satisfying the given predicate dropped from the beginning of the string. <br /></td></tr>
<tr class="separator:a4b743a75e40f0134d349b40021efbe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc8fc7420cb176650255561fd8c7b50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebc8fc7420cb176650255561fd8c7b50"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#aebc8fc7420cb176650255561fd8c7b50">consume_front</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Prefix)</td></tr>
<tr class="memdesc:aebc8fc7420cb176650255561fd8c7b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> has the given prefix and removes that prefix. <br /></td></tr>
<tr class="separator:aebc8fc7420cb176650255561fd8c7b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a01c8e37020d1e5a9771557640b1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a894a01c8e37020d1e5a9771557640b1b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a894a01c8e37020d1e5a9771557640b1b">consume_back</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Suffix)</td></tr>
<tr class="memdesc:a894a01c8e37020d1e5a9771557640b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> has the given suffix and removes that suffix. <br /></td></tr>
<tr class="separator:a894a01c8e37020d1e5a9771557640b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d3f800c7cb8f445e9482e7b63b5944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#af2d3f800c7cb8f445e9482e7b63b5944">slice</a> (size_t Start, size_t End) const </td></tr>
<tr class="memdesc:af2d3f800c7cb8f445e9482e7b63b5944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the substring from [Start, End).  <a href="#af2d3f800c7cb8f445e9482e7b63b5944">More...</a><br /></td></tr>
<tr class="separator:af2d3f800c7cb8f445e9482e7b63b5944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93b2e8eeaf7f6f3d56a4e053e044c44"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ac93b2e8eeaf7f6f3d56a4e053e044c44">split</a> (char Separator) const </td></tr>
<tr class="memdesc:ac93b2e8eeaf7f6f3d56a4e053e044c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator character.  <a href="#ac93b2e8eeaf7f6f3d56a4e053e044c44">More...</a><br /></td></tr>
<tr class="separator:ac93b2e8eeaf7f6f3d56a4e053e044c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d92b201fdcf4968cf6ac2576a44213"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a51d92b201fdcf4968cf6ac2576a44213">split</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Separator) const </td></tr>
<tr class="memdesc:a51d92b201fdcf4968cf6ac2576a44213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="#a51d92b201fdcf4968cf6ac2576a44213">More...</a><br /></td></tr>
<tr class="separator:a51d92b201fdcf4968cf6ac2576a44213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e5b9ea7247563df48ff5984a32270c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a19e5b9ea7247563df48ff5984a32270c">split</a> (<a class="el" href="classdawn_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt; &amp;A, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Separator, int MaxSplit=-1, bool KeepEmpty=true) const </td></tr>
<tr class="memdesc:a19e5b9ea7247563df48ff5984a32270c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into substrings around the occurrences of a separator string.  <a href="#a19e5b9ea7247563df48ff5984a32270c">More...</a><br /></td></tr>
<tr class="separator:a19e5b9ea7247563df48ff5984a32270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c697e911ab298f5e94ab67abf958b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a11c697e911ab298f5e94ab67abf958b5">split</a> (<a class="el" href="classdawn_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt; &amp;A, char Separator, int MaxSplit=-1, bool KeepEmpty=true) const </td></tr>
<tr class="memdesc:a11c697e911ab298f5e94ab67abf958b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into substrings around the occurrences of a separator character.  <a href="#a11c697e911ab298f5e94ab67abf958b5">More...</a><br /></td></tr>
<tr class="separator:a11c697e911ab298f5e94ab67abf958b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfcc26bba411ce853462ceda4f9ec4a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#acbfcc26bba411ce853462ceda4f9ec4a">rsplit</a> (char Separator) const </td></tr>
<tr class="memdesc:acbfcc26bba411ce853462ceda4f9ec4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the last occurrence of a separator character.  <a href="#acbfcc26bba411ce853462ceda4f9ec4a">More...</a><br /></td></tr>
<tr class="separator:acbfcc26bba411ce853462ceda4f9ec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5899e965610edd331a7889f750c978c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5899e965610edd331a7889f750c978c8"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a5899e965610edd331a7889f750c978c8">ltrim</a> (char Char) const </td></tr>
<tr class="memdesc:a5899e965610edd331a7889f750c978c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive <code>Char</code> characters starting from the the left removed. <br /></td></tr>
<tr class="separator:a5899e965610edd331a7889f750c978c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9660802a82846a8122c94d321171e77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9660802a82846a8122c94d321171e77"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ac9660802a82846a8122c94d321171e77">ltrim</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const </td></tr>
<tr class="memdesc:ac9660802a82846a8122c94d321171e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the left removed. <br /></td></tr>
<tr class="separator:ac9660802a82846a8122c94d321171e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a55d23ff98c93288de45c5ff6e109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c3a55d23ff98c93288de45c5ff6e109"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a8c3a55d23ff98c93288de45c5ff6e109">rtrim</a> (char Char) const </td></tr>
<tr class="memdesc:a8c3a55d23ff98c93288de45c5ff6e109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive <code>Char</code> characters starting from the right removed. <br /></td></tr>
<tr class="separator:a8c3a55d23ff98c93288de45c5ff6e109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1294b9beb9a65e802fe17b86f3ca9c72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1294b9beb9a65e802fe17b86f3ca9c72"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a1294b9beb9a65e802fe17b86f3ca9c72">rtrim</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const </td></tr>
<tr class="memdesc:a1294b9beb9a65e802fe17b86f3ca9c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the right removed. <br /></td></tr>
<tr class="separator:a1294b9beb9a65e802fe17b86f3ca9c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030d1bd3a237018341c8c58005b342c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a030d1bd3a237018341c8c58005b342c2"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a030d1bd3a237018341c8c58005b342c2">trim</a> (char Char) const </td></tr>
<tr class="memdesc:a030d1bd3a237018341c8c58005b342c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive <code>Char</code> characters starting from the left and right removed. <br /></td></tr>
<tr class="separator:a030d1bd3a237018341c8c58005b342c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb3baccbe63820ba9c2f4f63786c68f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdb3baccbe63820ba9c2f4f63786c68f"></a>
<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#acdb3baccbe63820ba9c2f4f63786c68f">trim</a> (<a class="el" href="classdawn_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const </td></tr>
<tr class="memdesc:acdb3baccbe63820ba9c2f4f63786c68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the left and right removed. <br /></td></tr>
<tr class="separator:acdb3baccbe63820ba9c2f4f63786c68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a01bf661b2b4ae8ace36fee2dca906de6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01bf661b2b4ae8ace36fee2dca906de6"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>npos</b> = ~size_t(0)</td></tr>
<tr class="separator:a01bf661b2b4ae8ace36fee2dca906de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acb9e390afd7cdca623fe4e4b5709eb9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb9e390afd7cdca623fe4e4b5709eb9b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#acb9e390afd7cdca623fe4e4b5709eb9b">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &amp;<a class="el" href="classdawn_1_1StringRef.html#a2743adb29ece0bc232ba2289cf355141">str</a>)</td></tr>
<tr class="memdesc:acb9e390afd7cdca623fe4e4b5709eb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to stream. <br /></td></tr>
<tr class="separator:acb9e390afd7cdca623fe4e4b5709eb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructors</h2></td></tr>
<tr class="memitem:ad0fbc1062246c47610886377b3b927f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0fbc1062246c47610886377b3b927f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#ad0fbc1062246c47610886377b3b927f4">StringRef</a> ()=default</td></tr>
<tr class="memdesc:ad0fbc1062246c47610886377b3b927f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty string ref. <br /></td></tr>
<tr class="separator:ad0fbc1062246c47610886377b3b927f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1326e77764fdfc34a64bcd69a3dfe0c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1326e77764fdfc34a64bcd69a3dfe0c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a1326e77764fdfc34a64bcd69a3dfe0c0">StringRef</a> (std::nullptr_t)=delete</td></tr>
<tr class="memdesc:a1326e77764fdfc34a64bcd69a3dfe0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable conversion from nullptr. This prevents things like if (S == nullptr) <br /></td></tr>
<tr class="separator:a1326e77764fdfc34a64bcd69a3dfe0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb31e4079e3455bf98fc2f373001a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cb31e4079e3455bf98fc2f373001a3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a3cb31e4079e3455bf98fc2f373001a3d">StringRef</a> (const char *Str)</td></tr>
<tr class="memdesc:a3cb31e4079e3455bf98fc2f373001a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a cstring. <br /></td></tr>
<tr class="separator:a3cb31e4079e3455bf98fc2f373001a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c5ea42265ebfb7a7dda82f2629891a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45c5ea42265ebfb7a7dda82f2629891a"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a45c5ea42265ebfb7a7dda82f2629891a">StringRef</a> (const char *<a class="el" href="classdawn_1_1StringRef.html#a107055aa239a9f486c35b0f682c4a6fd">data</a>, size_t length)</td></tr>
<tr class="memdesc:a45c5ea42265ebfb7a7dda82f2629891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a pointer and length. <br /></td></tr>
<tr class="separator:a45c5ea42265ebfb7a7dda82f2629891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee331d63a67de98414a05c800a0d167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ee331d63a67de98414a05c800a0d167"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdawn_1_1StringRef.html#a4ee331d63a67de98414a05c800a0d167">StringRef</a> (const std::string &amp;Str)</td></tr>
<tr class="memdesc:a4ee331d63a67de98414a05c800a0d167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from an std::string. <br /></td></tr>
<tr class="separator:a4ee331d63a67de98414a05c800a0d167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d93e8c702f14aa406c9e32c13be0437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d93e8c702f14aa406c9e32c13be0437"></a>
static <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>withNullAsEmpty</b> (const char *<a class="el" href="classdawn_1_1StringRef.html#a107055aa239a9f486c35b0f682c4a6fd">data</a>)</td></tr>
<tr class="separator:a4d93e8c702f14aa406c9e32c13be0437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represent a constant reference to a string, i.e. a character array and a length, which need not be null terminated. </p>
<p>This class does not own the string data, it is expected to be used in situations where the character data resides in some other buffer, whose lifetime extends past that of the <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a>. For this reason, it is not in general safe to store a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a>. </p>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00052">52</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8090209bfc13efd61b7b42f99909d057"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type dawn::StringRef::consumeInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current string as an integer of the specified radix. </p>
<p>If <code>Radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string does not begin with a number of the specified radix, this returns true to signify the error. The string is considered erroneous if empty or if it overflows T. The portion of the string representing the discovered numeric value is removed from the beginning of the string. </p>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00417">417</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad504a74304c2847769a7e9cfcf8e0ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dawn::StringRef::edit_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>AllowReplacements</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>MaxEditDistance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the edit distance between this string and another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>The string to compare this string against. </td></tr>
    <tr><td class="paramname">AllowReplacements</td><td>Whether to allow character replacements (change one character into another) as a single operation, rather than as two operations (an insertion and a removal). </td></tr>
    <tr><td class="paramname">MaxEditDistance</td><td>If non-zero, the maximum edit distance that this routine is allowed to compute. If the edit distance will exceed that maximum, returns <code>MaxEditDistance+1</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of character insertions, removals, or (if <code>AllowReplacements</code> is <code>true</code>) replacements needed to transform one of the given strings into the other. If zero, the strings are identical. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00105">105</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1bad06986daa9948f66b5c6fc90c6fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character <code>C</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>C</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00237">237</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2fef30c745c806174041c5e10483a325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first string <code>Str</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>Str</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00135">135</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41a4405d85631a520e8094d397b2e994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type dawn::StringRef::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first character in the string that is not <code>C</code> or npos if not found. </p>
<p>find_first_not_of - Find the first character in the string that is not </p><ul>
<li>C or npos if not found. </li>
</ul>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00243">243</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae636093995f4674ce79988342688a3fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type dawn::StringRef::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first character in the string that is not in the string <code>Chars</code>, or npos if not found. </p>
<p><b>Complexity:</b> O(<a class="el" href="classdawn_1_1StringRef.html#a8d2803a41e8fbee9defb19f20747beaf" title="Get the string size. ">size()</a> + Chars.size()) </p>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00250">250</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2d1a13ecf028373849ca2430fb75f62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type dawn::StringRef::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first character in the string that is in <code>Chars</code>, or npos if not found. </p>
<p><b>Complexity:</b> O(<a class="el" href="classdawn_1_1StringRef.html#a8d2803a41e8fbee9defb19f20747beaf" title="Get the string size. ">size()</a> + Chars.size()) </p>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00230">230</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a275bc8a0c3771329b141f16890224869"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::find_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character satisfying the predicate <code>F</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character satisfying <code>F</code> starting from <code>From</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00256">256</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa134e987ac930238c483740b34bff1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::find_if_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character not satisfying the predicate <code>F</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character not satisfying <code>F</code> starting from <code>From</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00270">270</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="a02e3cb4221549c83b2402d8b5d52b2a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type dawn::StringRef::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the last character in the string that is not in <code>Chars</code>, or npos if not found. </p>
<p><b>Complexity:</b> O(<a class="el" href="classdawn_1_1StringRef.html#a8d2803a41e8fbee9defb19f20747beaf" title="Get the string size. ">size()</a> + Chars.size()) </p>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00279">279</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b746c28753a11bb900cf2a7d3a37e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type dawn::StringRef::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the last character in the string that is in <code>C</code>, or npos if not found. </p>
<p><b>Complexity:</b> O(<a class="el" href="classdawn_1_1StringRef.html#a8d2803a41e8fbee9defb19f20747beaf" title="Get the string size. ">size()</a> + Chars.size()) </p>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00261">261</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5de6a6ff661683672a21697c84127f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::find_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first character <code>C</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>C</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00069">69</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b1b214811d4ec37a993738e7621dec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::find_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first string <code>Str</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>Str</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00184">184</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4be8de0cd0874afac40d24fc5bd856fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type dawn::StringRef::getAsInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current string as an integer of the specified radix. </p>
<p>If <code>Radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string is invalid or if only a subset of the string is valid, this returns true to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00384">384</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc7a0d03452514ae39cdbfc3ba657eee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&gt;::type&amp; dawn::StringRef::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow accidental assignment from a temporary std::string. </p>
<p>The declaration here is extra complicated so that <code>stringRef = {}</code> and <code>stringRef = "abc"</code> continue to select the move assignment operator. </p>

</div>
</div>
<a class="anchor" id="a2212a6ab10bdc615aab91258ff5b923b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last character <code>C</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>C</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00287">287</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="a602e32d304211281e653405057a85912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last string <code>Str</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>Str</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00206">206</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a174b269c88b2f3284a62af898cab8ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::rfind_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last character <code>C</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>C</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00195">195</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74f92eb7c4acecaeb7d8e09787659091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dawn::StringRef::rfind_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last string <code>Str</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>Str</code>, or npos if not found. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00218">218</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbfcc26bba411ce853462ceda4f9ec4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&gt; dawn::StringRef::rsplit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the last occurrence of a separator character. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is minimal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00611">611</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="af2d3f800c7cb8f445e9482e7b63b5944"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a> dawn::StringRef::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>End</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the substring from [Start, End). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned. </td></tr>
    <tr><td class="paramname">End</td><td>The index following the last character to include in the substring. If this is npos or exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. If this is less than <code>Start</code>, an empty string will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00539">539</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac93b2e8eeaf7f6f3d56a4e053e044c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&gt; dawn::StringRef::split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator character. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00553">553</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51d92b201fdcf4968cf6ac2576a44213"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdawn_1_1StringRef.html">StringRef</a>, <a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&gt; dawn::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator string. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00568">568</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19e5b9ea7247563df48ff5984a32270c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dawn::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>KeepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split into substrings around the occurrences of a separator string. </p>
<p>Each substring is stored in <code>A</code>. If <code>MaxSplit</code> is &gt;= 0, at most <code>MaxSplit</code> splits are done and consequently &lt;= <code>MaxSplit</code> + 1 elements are added to A. If <code>KeepEmpty</code> is false, empty strings are not added to <code>A</code>. They still count when considering <code>MaxSplit</code>. An useful invariant is that Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Where to put the substrings. </td></tr>
    <tr><td class="paramname">Separator</td><td>The string to split on. </td></tr>
    <tr><td class="paramname">MaxSplit</td><td>The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">KeepEmpty</td><td>True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00290">290</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11c697e911ab298f5e94ab67abf958b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dawn::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdawn_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classdawn_1_1StringRef.html">StringRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>KeepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split into substrings around the occurrences of a separator character. </p>
<p>Each substring is stored in <code>A</code>. If <code>MaxSplit</code> is &gt;= 0, at most <code>MaxSplit</code> splits are done and consequently &lt;= <code>MaxSplit</code> + 1 elements are added to A. If <code>KeepEmpty</code> is false, empty strings are not added to <code>A</code>. They still count when considering <code>MaxSplit</code>. An useful invariant is that Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Where to put the substrings. </td></tr>
    <tr><td class="paramname">Separator</td><td>The string to split on. </td></tr>
    <tr><td class="paramname">MaxSplit</td><td>The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">KeepEmpty</td><td>True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="StringRef_8cpp_source.html#l00316">316</a> of file <a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cea466138a523489a684676bb233d60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a> dawn::StringRef::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the substring from [Start, Start + N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned. </td></tr>
    <tr><td class="paramname">N</td><td>The number of characters to included in the substring. If N exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00459">459</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c59fbb1c520e0e0c53548525a3e8359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a> dawn::StringRef::take_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classdawn_1_1StringRef.html" title="Represent a constant reference to a string, i.e. a character array and a length, which need not be nu...">StringRef</a> equal to 'this' but with only the first <code>N</code> elements remaining. </p>
<p>If <code>N</code> is greater than the length of the string, the entire string is returned. </p>

<p>Definition at line <a class="el" href="StringRef_8h_source.html#l00475">475</a> of file <a class="el" href="StringRef_8h_source.html">StringRef.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/dawn/Support/<a class="el" href="StringRef_8h_source.html">StringRef.h</a></li>
<li>src/dawn/Support/<a class="el" href="StringRef_8cpp_source.html">StringRef.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>dawn</b></li><li class="navelem"><a class="el" href="classdawn_1_1StringRef.html">StringRef</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
